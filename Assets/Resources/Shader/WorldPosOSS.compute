// This computeshader takes the tilemask, baycentric coordinates/vertex ids, and the vertex positions andcreates a tile map with the world postions 
#pragma kernel CSMain

Matrix localToWorldMatrix;
Texture2D<float3> tileMask;
Texture2D<uint3> vertexIds;
Texture2D<float3> baycentCoords;
RWStructuredBuffer<float3> vertexPositions;
RWStructuredBuffer<float3> vertexNormals;
RWTexture2D<float3> WorldPos;
RWTexture2D<float3> Normals;

//this takes the pixel position in the texture atlas and calculates the uv and mipmap coordinates
float3 px_to_uv_coords(uint2 xy, uint atlasWidth, uint atlasHeight) {
	uint mip = 0;

	for (uint w = atlasWidth / 2; xy.x >= w; w /= 2) {
		mip += 1;
		xy.x -= w;
	}

	uint widthAtLevel = atlasWidth / 2 >> mip;
	uint heightAtLevel = atlasHeight >> mip;

	uint offset = atlasWidth - 2 * widthAtLevel;

	float2 uv = float2((float)xy.x / widthAtLevel, (float)xy.y / heightAtLevel);

	return float3(uv, mip);
}


[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	if (tileMask[(uint2)(id.xy / 8)].x == 0) { return; }

	//Atlas Postion__________________________________________________
	uint atlasWidth, atlasHeight;
	WorldPos.GetDimensions(atlasWidth, atlasHeight);

	float3 uvMip = px_to_uv_coords(id.xy, atlasWidth, atlasHeight);

	uint widthAtLevel = atlasWidth / 2 >> (uint) uvMip.z;
	uint heightAtLevel = atlasHeight >> (uint) uvMip.z;

	uint offset = atlasWidth - 2 * widthAtLevel;

	if (id.xy.x - offset > widthAtLevel || id.xy.y > heightAtLevel) { return; }

	uint2 xy = uvMip.xy * uint2(atlasWidth / 2, atlasHeight);

	xy = (baycentCoords[xy].x != 0 || baycentCoords[xy].y != 0 || baycentCoords[xy].z != 0) ? xy :
		(baycentCoords[xy + uint2(1, 0)].x != 0 || baycentCoords[xy + uint2(1, 0)].y != 0 || baycentCoords[xy + uint2(1, 0)].z != 0) ? xy + uint2(1, 0) :
		(baycentCoords[xy + uint2(0, 1)].x != 0 || baycentCoords[xy + uint2(0, 1)].y != 0 || baycentCoords[xy + uint2(0, 1)].z != 0) ? xy + uint2(0, 1) :
		(baycentCoords[xy + uint2(-1, 0)].x != 0 || baycentCoords[xy + uint2(-1, 0)].y != 0 || baycentCoords[xy + uint2(-1, 0)].z != 0) ? xy + uint2(-1, 0) :
		(baycentCoords[xy + uint2(0, -1)].x != 0 || baycentCoords[xy + uint2(0, -1)].y != 0 || baycentCoords[xy + uint2(0, -1)].z != 0) ? xy + uint2(0, -1) : xy;

	if (baycentCoords[xy].x == 0 && baycentCoords[xy].y == 0 && baycentCoords[xy].z == 0) {
		return;
	}
	//world position
	float3 localPos = vertexPositions[vertexIds[xy].x] * baycentCoords[xy].x
		+ vertexPositions[vertexIds[xy].y] * baycentCoords[xy].y
		+ vertexPositions[vertexIds[xy].z] * baycentCoords[xy].z;

	float4 worldPos = mul(localToWorldMatrix, float4(localPos, 1));
	WorldPos[id.xy] = worldPos;// +float3(id.x / 8192.0, id.y / 8192.0, 0)) / 2;

	//normals
	float3 localNormal = vertexNormals[vertexIds[xy].x] * baycentCoords[xy].x
		+ vertexNormals[vertexIds[xy].y] * baycentCoords[xy].y
		+ vertexNormals[vertexIds[xy].z] * baycentCoords[xy].z;

	float4 worldNormal = mul(localToWorldMatrix, float4(localNormal, 0));
	Normals[id.xy] = worldNormal;// +float3(id.x / 8192.0, id.y / 8192.0, 0)) / 2;
}
