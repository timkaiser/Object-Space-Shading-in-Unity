// This computeshader takes the tilemask, baycentric coordinates/vertex ids, and the vertex positions andcreates a tile map with the world postions 
#pragma kernel CSMain

Matrix localToWorldMatrix;
Texture2D<float3> tileMask;
Texture2D<uint3> vertexIds;
Texture2D<float3> baycentCoords;
RWStructuredBuffer<float3> vertexPositions;
RWTexture2D<float3> Output;

//this takes the pixel position in the texture atlas and calculates the uv and mipmap coordinates
float3 px_to_uv_coords(uint2 xy, uint atlasWidth, uint atlasHeight) {
	uint mip = 0;

	for (uint w = atlasWidth / 2; xy.x >= w; w /= 2) {
		mip += 1;
		xy.x -= w;
	}

	uint widthAtLevel = atlasWidth / 2 >> mip;
	uint heightAtLevel = atlasHeight >> mip;

	uint offset = atlasWidth - 2 * widthAtLevel;

	float2 uv = float2((float)xy.x / widthAtLevel, (float)xy.y / heightAtLevel);

	return float3(uv, mip);
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	if (tileMask[(uint2)(id.xy / 8)].x == 0) {return; }

	uint atlasWidth, atlasHeight;
	Output.GetDimensions(atlasWidth, atlasHeight);

	float3 uvMip = px_to_uv_coords(id.xy, atlasWidth, atlasHeight);

	uint widthAtLevel = atlasWidth / 2 >> (uint) uvMip.z;
	uint heightAtLevel = atlasHeight >> (uint) uvMip.z;

	uint offset = atlasWidth - 2 * widthAtLevel;

	if (id.xy.x - offset > widthAtLevel || id.xy.y > heightAtLevel) { return; }

	uint2 xy = uvMip.xy * uint2(atlasWidth / 2, atlasHeight);

	float3 localPos = vertexPositions[vertexIds[xy].x] * baycentCoords[xy].x
		+ vertexPositions[vertexIds[xy].y] * baycentCoords[xy].y
		+ vertexPositions[vertexIds[xy].z] * baycentCoords[xy].z;

	float4 worldPos = mul(localToWorldMatrix, float4(localPos, 1));


	Output[id.xy] = worldPos;
	

}
