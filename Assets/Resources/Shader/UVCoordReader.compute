//this compute shader takes the rendered uv and mip map coordinates of the first pass and writes a tilemask of wich parts of the texture gets actually rendered

#pragma kernel CSMain

RWStructuredBuffer<uint> Stats;
Texture2D<int2> IDandMip;
Texture2D<float2> UV;
RWTexture2D<float3> Output;
RWTexture2D<float3> Debug;
int ID;

//takes uv coords between (0,0) and (1,1) and mipmap level and calculates position in texture atlas
uint2 uv_to_px_coords(float2 uv, uint mip, uint atlasWidth, uint atlasHeight) {
	uint widthAtLevel = atlasWidth / 2 >> mip;
	uint heightAtLevel = atlasHeight >> mip;

	uint2 xy = uint2(widthAtLevel * uv.x, heightAtLevel * uv.y);

	uint offset = atlasWidth - 2 * widthAtLevel;

	return uint2(xy.x + offset, xy.y);

}

//main part of compute shader
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	
	int2 idAndMip = IDandMip[id.xy];

	float2 uv = UV[id.xy];

	if (idAndMip.x != ID) { return; }

	uint width, height;
	Output.GetDimensions(width, height);

	uint2 xy = uv_to_px_coords(uv, idAndMip.y, width, height);

	InterlockedAdd(Stats[0], 1);

	Output[xy] = float3(1, 0, 0);

}


